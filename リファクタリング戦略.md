# リファクタリング戦略
## 基本方針
書籍『リファクタリング』で紹介されるような、小さなステップで段階的かつ安全な手順で進める。
なおかつ自動テストがないコードベースに対して、書籍『レガシーコード改善ガイド』紹介されるような、まず自動テストを可能とする接合部を安全に作れるような手順で進める。

また上記のような安全な手順を取っていることがわかるよう、通常業務よりも細かい粒度でコミットログを残していく。

## 目指す形
RxSwiftを用いたMVVMを目指す。
ViewとViewModelの間は
- View -> ViewModelのイベント通知はメソッド呼び出し
- ViewModel -> Viewの状態更新はRxSwiftを用いたバインディング

で行う。

## 進め方案
1. リバーシのゲームとしての判定・状態管理が`BoardView`に代表されるViewの表示状態と結合しているため、切り離していく。
     1. `ReversiGameRepository`を作成し、ゲームのセーブ/ロードを委譲する。
     1. `ViewController`に`var game: ReversiGame`を作成し、ゲームの進行に合わせて`game`の状態も追従するようにする。
     1. ゲームの判定・状態管理を`ReversiGame`に移す。
1. ゲーム全体の進行ロジックを`ViewModel`に移す。
    1. まずMVPのような状態を目指す。`ViewModel`（に最終的にはなるもの）に`ViewController`への参照を持たせ、処理を段階的に`ViewModel`へ移していく。その最中移していない処理は`ViewController`の参照を通して呼び出す。この過程で不必要なpublicが増えるのは妥協し、リファクタ完了後に不必要なpublicを削除する。
    1. RxSwiftを導入して部分的にバインディングでのView更新部分を増やしていく。
1. 設計を変更する。
    1. `ViewModel`のインターフェースを介して、各振る舞いをテストで保護する。振る舞い単位でのテストとなるため、手順が複雑になったり、アサーションが多くなるのは一旦受け入れる。可能であればあとでシンプルに修正したい。
    1. テストで保護した範囲を設計変更していく。

### 設計変更案
#### Reducerを用いた設計は断念
リバーシのゲームとしての静的な振る舞いだけであれば
`今の状態 + アクション -> 次の状態`
とReducerを導入した設計にできるが、リセットとプレイヤーモード変更が問題。
どちらも優先的な割り込みとして処理する必要があり、なおかつ状況によっては進行中の処理をキャンセルする必要がある。
（ディスクの描画中のリセット、コンピューターが試行中にManualにモードを戻したケース）
関数的にできる部分の割合の方が少ない設計案しか浮かばないため、Reducerは断念。

#### 状態マシンを目指す
- ユーザー入力待ち
- コンピューター入力待ち
- パス了承待ち
- ディスク裏返し中
- ゲーム終了

という状態を行き来する状態マシンとして捉えることができそうなので、Stateパターンを用いた設計を目指してみる。

Stateパターンは状態数の追加に対しては強いが、状態遷移を起こす行動数の追加に対しては弱い。また処理が各状態にばらけてしまい、全体を把握しづらくなるリスクもある。
それに対し、
- 今回のリバーシにはリファクタリング中、振る舞いを維持するため行動数は増えない
- リファクタリング前の手続き的なコードよりは、各状態に処理がばらけたStateパターンの方が理解がより容易ではないかと予想する

という理由でStateパターンを用いた状態マシンへの設計変更を目指すことにする。

## 既知バグ
2つのバグを発見済みなので、まずリグレッションテストを自動テストで準備し、その次にバグを再現する自動テストを書き修正していく。

### ディスクを裏返す処理の順番が仕様と異なる: 修正済み
[README](README.md)内「ディスクのアニメーション」に記載されている仕様
> - 左上、上、右上、右、右下、下、左下、左の最大 8 列のディスクが裏返る可能性があるが、ここに列挙した順に、各列内のディスクを裏返す

とあるが、左下と左の順番が逆になっている。

#### 再現手順
通常のゲーム進行中で検証可能な盤面に至ることが難しいので省略。
左下と左の順番が、左が優先されていることだけであれば容易に検証可能。

#### テストケース
初期値
```
xxxxx---
xooox---
xo#ox---
xooox---
xxxxx---
--------
--------
--------
```
の`#`の位置に黒のディスクを置いた時
```
xxxxx---
x234x---
x915x---
x876x---
xxxxx---
--------
--------
--------
```
の順でディスクを置く・裏返すアニメーションが実行されることを期待する自動テストを作成する。

### 次にプレイヤーの有効な手が存在しない状態でゲームを開始すると進行不能となる: 修正済み
ゲーム中、次にプレイヤーの有効な手が存在しない場合アラートが表示される。
しかしゲーム開始時読み込んだファイルが、次にプレイヤーの有効な手が存在しない状態だと進行不能になる。
- プレイヤーモードが"Manual": どこにもディスクを置くことができず、ターンが相手プレイヤーにも渡らない。"Reset"ボタンを押すことができるのみ。
- プレイヤーモードが"Computer": クラッシュする。

#### 再現手順
有効な手が存在せずパスするアラートが表示されている最中にアプリを再起動する。

#### テストケース
初期値
```
ox------
--------
--------
--------
--------
--------
--------
--------
```
で黒のターンで開始すると、相手プレイヤーにターンが移ることを期待する自動テストを作成する。

### リセット確認アラート表示中にパスするアラートが表示されない: 修正済み
リセット確認アラート表示中、裏でコンピューターが操作を続け置く場所がなくなると、パスするアラートの表示を試みるが
`Attempt to present <UIAlertController: *> on <Reversi.ViewController: *> (from <Reversi.ViewController: *>) which is already presenting <UIAlertController: *>.`
とログが出て、パスするアラートは表示されない。
リセット確認アラートをCancelで閉じてもパスするアラートは表示されず、ゲーム継続不能となる。

#### 再現手順
通常のゲーム進行中で検証可能な盤面に至ることが難しいので省略。

#### テストケース
おそらくXCUITestも可能だけれど、手動テストで十分リグレッションテスト可能。
ゲーム読み込み部分を一時的に変更し、以下のゲーム初期状態をハードコーディングする。
```
xo----ox
--------
--------
--------
--------
--------
--------
--------
```
両プレイヤーのプレイモードはコンピューターで黒のターンで開始する。
1つ目の黒が置かれる前にResetボタンを押しリセット確認アラートを表示しておく。
